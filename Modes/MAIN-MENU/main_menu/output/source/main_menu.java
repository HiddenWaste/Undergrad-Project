/* autogenerated by Processing revision 1293 on 2025-03-17 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import oscP5.*;
import netP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class main_menu extends PApplet {




OscP5 oscP5;
NetAddress supercollider;

// Persistent buffers
PGraphics mainBuffer;
PGraphics textBuffer;
PGraphics scanlineTexture;

// Shader for background
PShader gradientShader;

// Visual parameters
float volume = 0;
float targetVolume = 0;
float centroid = 0;
float targetCentroid = 0;
float lastOnsetTime = 0;
float noiseTime = 0;
float colorBalance = 0.5f;
float targetColorBalance = 0.5f;
float targetChromAb = 0;

// Control Variables (adjust these to taste)
float NOISE_SPEED = 0.005f;        // Reduced from 0.01 for smoother movement
float TEXT_FLOAT_SPEED = 0.005f;   // Reduced from 0.01 for smoother floating
float TEXT_FLOAT_AMOUNT = 30;     // Amount of text float in pixels
float CHROME_AB_MAX = 15;         // Maximum chromatic aberration
float CHROME_AB_SMOOTH = 0.95f;    // Smoothing for chromatic aberration (higher = slower)
float SCAN_LINE_SPEED = 0.5f;      // Reduced from 0.8 for smoother movement
float NOISE_AMOUNT = 0.001f;       // Amount of noise overlay
int NOISE_PARTICLES = 80;         // Reduced from 100 for less visual noise
float NOISE_ALPHA = 30;           // Reduced from 40 for subtler effect
int TEXT_UPDATE_RATE = 1;         // Update text every frame for smoother movement
float TEXT_SIZE = 120;            // Size of the text
float COLOR_BALANCE_INTENSITY = 2.0f; // Scalar for color balance effect (0.0 - 2.0)

// Smoothing constants
float PARAM_SMOOTH_FACTOR = 0.05f; // Lower value = smoother/slower transitions (0.0-1.0)
float COLOR_SMOOTH_FACTOR = 0.03f; // Even slower transitions for color
float VOLUME_SMOOTH_FACTOR = 0.1f; // Responsive but not jittery

// VHS effect parameters
float chromAberrationStrength = 0;
float scanLineOffset = 0;

// Text parameters
PFont font;
float textY = 0;
float targetTextY = 0;

// Noise particles with persistence
class NoiseParticle {
  float x, y, brightness, life;
  
  NoiseParticle() {
    reset();
    // Randomize initial life so all particles don't appear at once
    life = random(0, 1);
  }
  
  public void reset() {
    x = random(width);
    y = random(height);
    brightness = random(100, 255);
    life = 1.0f;
  }
  
  public void update() {
    life -= random(0.01f, 0.05f);
    if (life <= 0) {
      reset();
    }
  }
  
  public void display() {
    float alpha = NOISE_ALPHA * life;
    fill(brightness, alpha);
    rect(x, y, 2, 2);
  }
}

NoiseParticle[] particles;

public void setup() {
  /* size commented out by preprocessor */;
  frameRate(60);
  
  // Initialize OSC
  oscP5 = new OscP5(this, 12000);
  supercollider = new NetAddress("127.0.0.1", 57120);
  
  // Load and setup shader
  gradientShader = loadShader("gradient.glsl");
  gradientShader.set("resolution", PApplet.parseFloat(width), PApplet.parseFloat(height));
  
  // Initialize persistent buffers
  mainBuffer = createGraphics(width, height, P2D);
  textBuffer = createGraphics(width, height, P2D);
  
  // Create scanline texture
  createScanlineTexture();
  
  // Load font
  font = createFont("Arial Bold", TEXT_SIZE);
  textFont(font);
  
  // Initialize noise particles
  particles = new NoiseParticle[NOISE_PARTICLES];
  for (int i = 0; i < particles.length; i++) {
    particles[i] = new NoiseParticle();
  }
  
  // Initialize debug system
  setupDebug();
}

public void createScanlineTexture() {
  scanlineTexture = createGraphics(width, height, P2D);
  scanlineTexture.beginDraw();
  scanlineTexture.background(0, 0);
  scanlineTexture.stroke(0, 30);
  for (int y = 0; y < height; y += 3) {
    scanlineTexture.line(0, y, width, y);
  }
  scanlineTexture.endDraw();
}

public void updateTextBuffer() {
  textBuffer.beginDraw();
  textBuffer.clear();
  textBuffer.textFont(font);
  textBuffer.textAlign(CENTER, CENTER);
  
  float baseX = width/2;
  float baseY = height/2 + textY;
  
  // Shadow
  textBuffer.fill(0, 80);
  textBuffer.text("P.A.C.E", baseX + 4, baseY + 4);
  
  // Less jagged text effect with controlled randomness
  int jaggedness = 3; // Reduced from 5 for less jagged effect
  for (int i = 0; i < jaggedness; i++) {
    // Use noise instead of random for smoother variation
    float offsetX = map(noise(i * 0.3f, frameCount * 0.01f), 0, 1, -1.5f, 1.5f);
    float offsetY = map(noise(i * 0.3f + 10, frameCount * 0.01f), 0, 1, -1.5f, 1.5f);
    float alpha = map(i, 0, jaggedness-1, 100, 255);
    textBuffer.fill(245, 245, 220, alpha);
    textBuffer.text("P.A.C.E", baseX + offsetX, baseY + offsetY);
  }
  
  textBuffer.fill(245, 245, 220);
  textBuffer.text("P.A.C.E", baseX, baseY);
  textBuffer.endDraw();
}

public void draw() {
  // Smooth parameter updates
  volume = lerp(volume, targetVolume, VOLUME_SMOOTH_FACTOR);
  centroid = lerp(centroid, targetCentroid, PARAM_SMOOTH_FACTOR);
  colorBalance = lerp(colorBalance, targetColorBalance, COLOR_SMOOTH_FACTOR);
  
  // Update parameters with smoother increments
  noiseTime += NOISE_SPEED;
  
  // Use a smoother sine function for text movement
  targetTextY = sin(frameCount * TEXT_FLOAT_SPEED) * TEXT_FLOAT_AMOUNT;
  textY = lerp(textY, targetTextY, 0.1f); // Smooth the text movement
  
  scanLineOffset = (scanLineOffset + SCAN_LINE_SPEED) % height;
  
  // Smooth chromatic aberration
  targetChromAb = map(volume, 0, 1, 0, CHROME_AB_MAX);
  chromAberrationStrength = lerp(chromAberrationStrength, targetChromAb, 1.0f - CHROME_AB_SMOOTH);
  
  // Draw gradient background using shader
  gradientShader.set("time", noiseTime);
  gradientShader.set("colorBalance", colorBalance);
  gradientShader.set("resolution", PApplet.parseFloat(width), PApplet.parseFloat(height));
  shader(gradientShader);
  rect(0, 0, width, height);
  resetShader();
  
  // Update text buffer every frame for smoother movement
  updateTextBuffer();
  
  // Apply chromatic aberration to text
  mainBuffer.beginDraw();
  mainBuffer.clear();
  
  // Red channel
  mainBuffer.tint(255, 0, 0);
  mainBuffer.image(textBuffer, -chromAberrationStrength, 0);
  
  // Blue channel
  mainBuffer.tint(0, 0, 255);
  mainBuffer.image(textBuffer, chromAberrationStrength, 0);
  
  // Green channel
  mainBuffer.tint(0, 255, 0);
  mainBuffer.image(textBuffer, 0, 0);
  mainBuffer.endDraw();
  
  // Draw main content
  image(mainBuffer, 0, 0);
  
  // Draw scanlines with offset
  tint(255);
  pushMatrix();
  translate(0, scanLineOffset);
  image(scanlineTexture, 0, -height);
  image(scanlineTexture, 0, 0);
  popMatrix();
  
  // Smoother noise overlay with persistent particles
  blendMode(ADD);
  noStroke();
  for (int i = 0; i < particles.length; i++) {
    particles[i].update();
    particles[i].display();
  }
  blendMode(BLEND);
  
  // Draw debug information if enabled
  updateDebug();
  drawDebug();
}

public void oscEvent(OscMessage msg) {
  if (msg.checkAddrPattern("/reich/volume")) {
    targetVolume = msg.get(0).floatValue();
    updateDebugValue("volume", volume);
    updateDebugValue("targetVolume", targetVolume);
  }
  else if (msg.checkAddrPattern("/reich/centroid")) {
    targetCentroid = msg.get(0).floatValue();
    updateDebugValue("centroid", centroid);
    // Smooth the color balance calculation
    targetColorBalance = map(targetCentroid, 200, 2000, 0, 1) * COLOR_BALANCE_INTENSITY;
  }
  else if (msg.checkAddrPattern("/reich/onset")) {
    lastOnsetTime = millis();
    registerOnset();
  }
}

public void keyPressed() {
  if (key == 'h' || key == 'H') {
    toggleDebug();
  }
}
// Debug system variables
boolean showDebug = false;
ArrayList<Float> recentVolumes;
ArrayList<Float> recentCentroids;
int maxDataPoints = 100;
float onsetCount = 0;
float lastOnsetCheck = 0;
float onsetsPerSecond = 0;

public void setupDebug() {
  recentVolumes = new ArrayList<Float>();
  recentCentroids = new ArrayList<Float>();
}

public void toggleDebug() {
  showDebug = !showDebug;
}

public void updateDebugValue(String type, float value) {
  if (type.equals("volume")) {
    if (recentVolumes.size() >= maxDataPoints) {
      recentVolumes.remove(0);
    }
    recentVolumes.add(value);
  } else if (type.equals("centroid")) {
    if (recentCentroids.size() >= maxDataPoints) {
      recentCentroids.remove(0);
    }
    recentCentroids.add(value);
  }
}

public void registerOnset() {
  onsetCount++;
}

public void updateDebug() {
  // Update onsets per second
  if (millis() - lastOnsetCheck >= 1000) {
    onsetsPerSecond = onsetCount;
    onsetCount = 0;
    lastOnsetCheck = millis();
  }
}

public void drawDebug() {
  if (!showDebug) return;
  
  // Create semi-transparent background for debug panel
  pushStyle();
  fill(0, 180);
  noStroke();
  rect(0, 0, 300, height);
  popStyle();
  
  float margin = 20;
  float lineHeight = 25;
  float y = margin;
  
  // Set up debug text style
  pushStyle();
  textAlign(LEFT);
  textSize(14);
  fill(255);  // White text
  
  // Basic info
  text("DEBUG INFORMATION:", margin, y);
  y += lineHeight * 1.5f;
  
  // Audio Analysis
  text("AUDIO ANALYSIS", margin, y);
  y += lineHeight;
  text(String.format("Volume: %.3f", volume), margin, y += lineHeight);
  text(String.format("Centroid: %.1f Hz", centroid), margin, y += lineHeight);
  text(String.format("Onsets/sec: %.1f", onsetsPerSecond), margin, y += lineHeight);
  y += lineHeight;
  
  // Visual Parameters
  text("VISUAL PARAMETERS", margin, y);
  y += lineHeight;
  text(String.format("FPS: %.1f", frameRate), margin, y += lineHeight);
  text(String.format("Color Balance: %.3f", colorBalance), margin, y += lineHeight);
  text(String.format("Chrome Aberration: %.2f", chromAberrationStrength), margin, y += lineHeight);
  y += lineHeight;
  
  // Control Variables
  text("CONTROL VARIABLES", margin, y);
  y += lineHeight;
  text(String.format("Color Balance Intensity: %.2f", COLOR_BALANCE_INTENSITY), margin, y += lineHeight);
  text(String.format("Chrome Ab Max: %.2f", CHROME_AB_MAX), margin, y += lineHeight);
  text(String.format("Chrome Ab Smooth: %.2f", CHROME_AB_SMOOTH), margin, y += lineHeight);
  
  // Draw volume history graph
  y += lineHeight * 1.5f;
  drawHistoryGraph("Volume History", recentVolumes, margin, y, 260, 50);
  
  // Draw centroid history graph
  y += 80;
  drawHistoryGraph("Frequency History", recentCentroids, margin, y, 260, 50);
  
  popStyle();
}

public void drawHistoryGraph(String label, ArrayList<Float> data, float x, float y, float w, float h) {
  pushStyle();
  // Draw background
  fill(0, 100);
  stroke(255, 30);
  rect(x, y, w, h);
  
  // Draw label
  fill(255);
  textSize(12);
  text(label, x, y - 5);
  
  if (data != null && data.size() > 1) {
    // Draw graph
    stroke(0, 255, 0, 200);  // Bright green for visibility
    strokeWeight(1.5f);
    noFill();
    beginShape();
    float xStep = w / (maxDataPoints - 1);
    for (int i = 0; i < data.size(); i++) {
      float value = data.get(i);
      float graphX = x + (i * xStep);
      float graphY = y + h - (value * h);
      vertex(graphX, graphY);
    }
    endShape();
    
    // Draw current value indicator
    if (data.size() > 0) {
      float currentValue = data.get(data.size() - 1);
      fill(255, 0, 0);
      noStroke();
      ellipse(x + w, y + h - (currentValue * h), 6, 6);
    }
  } else {
    // No data message
    fill(255, 100);
    textAlign(CENTER);
    text("Waiting for data...", x + w/2, y + h/2);
  }
  popStyle();
}


  public void settings() { size(1280, 720, P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "main_menu" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
